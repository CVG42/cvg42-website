
[{"content":"","date":"October 2025","externalUrl":null,"permalink":"/blog/","section":"Blogs","summary":"","title":"Blogs","type":"blog"},{"content":"","date":"October 2025","externalUrl":null,"permalink":"/","section":"Cristina Vera","summary":"","title":"Cristina Vera","type":"page"},{"content":"\rTest #\r","date":"October 2025","externalUrl":null,"permalink":"/blog/test-post/","section":"Blogs","summary":"My first post.","title":"Test","type":"blog"},{"content":"\rProject info #\rEngine: Unity\nPlatforms: Windows\nTeam members: 3\nA 2D pixel art golf platformer, where a cat, that has lost all of its lives and wakes up in Limbo, has to beat the Limbo God to come back to life. This project was built as hands-on training for an entry-level role, applying professional-grade architecture and best practices from day one. Following SOLID principles reviewed by the talented Iván Herrera.\nGolf Meowdyssey by ElErizio, cvg42, IXAL8\rFeatures #\rPhased shot system: adjust your direction, pick your strenght and shoot. Aim carefully as the force bar fills and empties to land the perfect shot. But be careful, your shots are limited. Free camera controls: move the camera before you make your shot to explore the level and plan your move. Power-ups: collect and use power-ups granted by cat spirits in each stage to overcome new challenges. Charming dialogues: follow a fun and mischievous narrative through in-game dialogues. Level variety: play across different themed stages, offering new puzzles. What I did #\rI took on multiple responsibilities throughout the project, focusing primarily on gameplay and systems programming\nArchitecture: designed the code architecture, ensuring each system followed the single-responsibilty principle for clean and scalable code. Systems programming: implemented core systems such as save/load system by slots, asynchornous scene loading using UniTask, UI, input and audio management. Gameplay programming: handled player ball throwing mechanic, fine-tuned physics, and built level selection logic. Debugging: resolved gameplay and system-level bugs and used Unity\u0026rsquo;s debugging tools along with Visual Studio\u0026rsquo;s debugging features to identify the issues if needed. Level design: designed the 4th level of the game implementing a time stoping power-up. UI programming: designed and created a functional main menu along with settings and pause menus with smooth transitions and animations using DOTween. CVG42/GOLF\r2D golf platformer game made in Unity\rC#\r0\r0\rCredits #\rProject Manager: Iván Herrera. Game and level designer, camera and dialogue system: Ivan Antonio Cats and pixel art animations: Joaquin Cuesta Art supervisor: Eric Rosas ","date":"June 2025","externalUrl":null,"permalink":"/highlights/golf-meowdyssey/","section":"Highlights","summary":"2D pixel art golf platformer where you have to beat the Limbo God in order to come back to life.","title":"Golf Meowdyssey","type":"highlights"},{"content":"\rProject info #\rEngine: Unity\nPlatforms: Windows\nTeam members: 3\nA 2D pixel art golf platformer, where a cat, that has lost all of its lives and wakes up in Limbo, has to beat the Limbo God to come back to life. This project was built as hands-on training for an entry-level role, applying professional-grade architecture and best practices from day one. Following SOLID principles reviewed by the talented Iván Herrera.\nGolf Meowdyssey by ElErizio, cvg42, IXAL8\rFeatures #\rPhased shot system: adjust your direction, pick your strenght and shoot. Aim carefully as the force bar fills and empties to land the perfect shot. But be careful, your shots are limited. Free camera controls: move the camera before you make your shot to explore the level and plan your move. Power-ups: collect and use power-ups granted by cat spirits in each stage to overcome new challenges. Charming dialogues: follow a fun and mischievous narrative through in-game dialogues. Level variety: play across different themed stages, offering new puzzles. What I did #\rI took on multiple responsibilities throughout the project, focusing primarily on gameplay and systems programming\nArchitecture: designed the code architecture, ensuring each system followed the single-responsibilty principle for clean and scalable code. Systems programming: implemented core systems such as save/load system by slots, asynchornous scene loading using UniTask, UI, input and audio management. Gameplay programming: handled player ball throwing mechanic, fine-tuned physics, and built level selection logic. Debugging: resolved gameplay and system-level bugs and used Unity\u0026rsquo;s debugging tools along with Visual Studio\u0026rsquo;s debugging features to identify the issues if needed. Level design: designed the 4th level of the game implementing a time stoping power-up. UI programming: designed and created a functional main menu along with settings and pause menus with smooth transitions and animations using DOTween. CVG42/GOLF\r2D golf platformer game made in Unity\rC#\r0\r0\rCredits #\rProject Manager: Iván Herrera. Game and level designer, camera and dialogue system: Ivan Antonio Cats and pixel art animations: Joaquin Cuesta Art supervisor: Eric Rosas ","date":"June 2025","externalUrl":null,"permalink":"/projects/golf-meowdyssey/","section":"Projects","summary":"2D pixel art golf platformer where you have to beat the Limbo God in order to come back to life.","title":"Golf Meowdyssey","type":"projects"},{"content":"","date":"June 2025","externalUrl":null,"permalink":"/highlights/","section":"Highlights","summary":"","title":"Highlights","type":"highlights"},{"content":"","date":"June 2025","externalUrl":null,"permalink":"/tags/level-design/","section":"Tags","summary":"","title":"Level Design","type":"tags"},{"content":"","date":"June 2025","externalUrl":null,"permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":"","date":"June 2025","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"","date":"June 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"June 2025","externalUrl":null,"permalink":"/tags/unity/","section":"Tags","summary":"","title":"Unity","type":"tags"},{"content":"","date":"November 2024","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":"","date":"November 2024","externalUrl":null,"permalink":"/tags/game-design/","section":"Tags","summary":"","title":"Game Design","type":"tags"},{"content":"\rProject info #\rEngine: Unity\nPlatforms: Android\nTeam members: 3\nAbout #\rSailor is a 3D puzzle game inspired by Monument Valley. You have lost your original body and now you must get it back by collecting the rosses across every level.\nFeatures #\rIntuitive controls: tap on the platforms to move. Move platforms: drag and rotate the platforms to position them correctly. Relaxing atmosphere: immerse yourself into the game\u0026rsquo;s world and unwind with the visuals, music and sounds. What I did #\rI was in charge of most of the coding, my main tasks included:\nSystems programming: implemented core systems such as game and player states, audio management and saving system. Gameplay programming: handled player movement (pathfinding) and path condition system. UI programming: developed a functional main menu, that also works as a level selector, along with settings and pause menus using DOTween. Cinematic: created the introductory cinematic using Unity\u0026rsquo;s Timeline feature. The most crucial part was the pathfinding system, which I\u0026rsquo;ll elaborate below.\nPathfinding #\rOne of my tasks was to create the pathfinding system. The game relies on perspective illusions where not every platform is physically connected, so each block acts as a node, storing its possible connection through a Walkable class, so only the blocks which had that class were able to be walked on.\nWhen the player selects a destination, the system searches for a route by checking the connected nodes and identify which blcoks are reachable thorough the function ExploreBlock.\nprivate void ExploreBlock(List\u0026lt;Transform\u0026gt; nextBlocks, List\u0026lt;Transform\u0026gt; visited) { Transform currentBlock = nextBlocks.First(); nextBlocks.Remove(currentBlock); if (currentBlock == clickedCube) return; foreach (WalkPath path in currentBlock.GetComponent\u0026lt;Walkable\u0026gt;().possiblePaths) { if (!visited.Contains(path.target) \u0026amp;\u0026amp; path.active) { nextBlocks.Add(path.target); path.target.GetComponent\u0026lt;Walkable\u0026gt;().previousBlock = currentBlock; } } visited.Add(currentBlock); if (nextBlocks.Any()) ExploreCube(nextBlocks, visited); } After the exploration is done, the route is build by tracing each of the cube\u0026rsquo;s previous block reference from the destination to the starting point.\nprivate void BuildPath() { Transform block = clickedBlock; while (block != currentBlock) { finalPath.Add(block); block = block.GetComponent\u0026lt;Walkable\u0026gt;().previousBlock; } finalPath.Insert(0, clickedBlock); FollowPath(); } Finally, the player can do the movement along the generated route using DOTween.\nprivate void FollowPath() { Sequence s = DOTween.Sequence(); for (int i = finalPath.Count - 1; i \u0026gt; 0; i--) { var target = finalPath[i].GetComponent\u0026lt;Walkable\u0026gt;(); float duration = target.isStair ? 0.3f : 0.2f; s.Append(transform.DOMove(target.GetWalkPoint(), duration).SetEase(Ease.Linear)); } s.AppendCallback(() =\u0026gt; Clear()); } All these steps where called in a main FindPath class.\nprivate void FindPath() { foreach (WalkPath path in currentBlock.GetComponent\u0026lt;Walkable\u0026gt;().possiblePaths) { if (path.active) { nextBlocks.Add(path.target); path.target.GetComponent\u0026lt;Walkable\u0026gt;().previousBlock = currentBlock; } } ExploreCube(nextBlocks, pastBlocks); BuildPath(); } Path conditions #\rAs a part of the pathfinding system, I had to implement conditions work to handle the platforms connect after the player drags or moves them complete the path.\nThere were two types of platforms, the ones that have to be rotated, and the ones that had to be moved along a horizontal or vertical axis. So I made a list for each type, List\u0026lt;RotationPathCondition\u0026gt; and List\u0026lt;PositionPathCondition\u0026gt;, which stored the expected rotation or position for each platform. Those values were compared against the platform\u0026rsquo;s current transform to determine if the path should be active or not.\nGoogle Play #\rThe game was originally shipped to the Google Play store.\nDISCLAIMER: The Google Play link might\u0026rsquo;ve expired due to issues with the maintenance of the game\u0026rsquo;s page apk.\rCredits #\r2D / 3D Art \u0026amp; Textures: Victor Contreras Level design: Ivan Antonio Gameplay programming (platform movement and interaction): Ivan Antonio ","date":"November 2024","externalUrl":null,"permalink":"/highlights/sailor/","section":"Highlights","summary":"You have lost your original body and now you must recover it by collecting all the roses. Puzzle-focused game inspired by Monument Valley.","title":"Sailor","type":"highlights"},{"content":"\rProject info #\rEngine: Unity\nPlatforms: Android\nTeam members: 3\nAbout #\rSailor is a 3D puzzle game inspired by Monument Valley. You have lost your original body and now you must get it back by collecting the rosses across every level.\nFeatures #\rIntuitive controls: tap on the platforms to move. Move platforms: drag and rotate the platforms to position them correctly. Relaxing atmosphere: immerse yourself into the game\u0026rsquo;s world and unwind with the visuals, music and sounds. What I did #\rI was in charge of most of the coding, my main tasks included:\nSystems programming: implemented core systems such as game and player states, audio management and saving system. Gameplay programming: handled player movement (pathfinding) and path condition system. UI programming: developed a functional main menu, that also works as a level selector, along with settings and pause menus using DOTween. Cinematic: created the introductory cinematic using Unity\u0026rsquo;s Timeline feature. The most crucial part was the pathfinding system, which I\u0026rsquo;ll elaborate below.\nPathfinding #\rOne of my tasks was to create the pathfinding system. The game relies on perspective illusions where not every platform is physically connected, so each block acts as a node, storing its possible connection through a Walkable class, so only the blocks which had that class were able to be walked on.\nWhen the player selects a destination, the system searches for a route by checking the connected nodes and identify which blcoks are reachable thorough the function ExploreBlock.\nprivate void ExploreBlock(List\u0026lt;Transform\u0026gt; nextBlocks, List\u0026lt;Transform\u0026gt; visited) { Transform currentBlock = nextBlocks.First(); nextBlocks.Remove(currentBlock); if (currentBlock == clickedCube) return; foreach (WalkPath path in currentBlock.GetComponent\u0026lt;Walkable\u0026gt;().possiblePaths) { if (!visited.Contains(path.target) \u0026amp;\u0026amp; path.active) { nextBlocks.Add(path.target); path.target.GetComponent\u0026lt;Walkable\u0026gt;().previousBlock = currentBlock; } } visited.Add(currentBlock); if (nextBlocks.Any()) ExploreCube(nextBlocks, visited); } After the exploration is done, the route is build by tracing each of the cube\u0026rsquo;s previous block reference from the destination to the starting point.\nprivate void BuildPath() { Transform block = clickedBlock; while (block != currentBlock) { finalPath.Add(block); block = block.GetComponent\u0026lt;Walkable\u0026gt;().previousBlock; } finalPath.Insert(0, clickedBlock); FollowPath(); } Finally, the player can do the movement along the generated route using DOTween.\nprivate void FollowPath() { Sequence s = DOTween.Sequence(); for (int i = finalPath.Count - 1; i \u0026gt; 0; i--) { var target = finalPath[i].GetComponent\u0026lt;Walkable\u0026gt;(); float duration = target.isStair ? 0.3f : 0.2f; s.Append(transform.DOMove(target.GetWalkPoint(), duration).SetEase(Ease.Linear)); } s.AppendCallback(() =\u0026gt; Clear()); } All these steps where called in a main FindPath class.\nprivate void FindPath() { foreach (WalkPath path in currentBlock.GetComponent\u0026lt;Walkable\u0026gt;().possiblePaths) { if (path.active) { nextBlocks.Add(path.target); path.target.GetComponent\u0026lt;Walkable\u0026gt;().previousBlock = currentBlock; } } ExploreCube(nextBlocks, pastBlocks); BuildPath(); } Path conditions #\rAs a part of the pathfinding system, I had to implement conditions work to handle the platforms connect after the player drags or moves them complete the path.\nThere were two types of platforms, the ones that have to be rotated, and the ones that had to be moved along a horizontal or vertical axis. So I made a list for each type, List\u0026lt;RotationPathCondition\u0026gt; and List\u0026lt;PositionPathCondition\u0026gt;, which stored the expected rotation or position for each platform. Those values were compared against the platform\u0026rsquo;s current transform to determine if the path should be active or not.\nGoogle Play #\rThe game was originally shipped to the Google Play store.\nDISCLAIMER: The Google Play link might\u0026rsquo;ve expired due to issues with the maintenance of the game\u0026rsquo;s page apk.\rCredits #\r2D / 3D Art \u0026amp; Textures: Victor Contreras Level design: Ivan Antonio Gameplay programming (platform movement and interaction): Ivan Antonio ","date":"November 2024","externalUrl":null,"permalink":"/projects/sailor/","section":"Projects","summary":"You have lost your original body and now you must recover it by collecting all the roses. Puzzle-focused game inspired by Monument Valley.","title":"Sailor","type":"projects"},{"content":"\rProject info #\rEngine: Unreal Engine 5.0\nPlatforms: Windows, Android\nA Katamari inspired game made in Unreal Engine 5 as practice project. Like in Katamari, the player controls a sphere that rolls around collecting objects scattered across the map before the time\u0026rsquo;s up. The more objects are collected, the bigger the sphere grows in size.\nFeatures #\rRoll: move around freely and roll over objects to collect them. Grow: pick up objects to increase your size and pick up even bigger objects. Speed boost: find and pick speed boosts around the map that will help you go faster. In-Game music selection: you can select the song you want to play with. Things I learned #\rThis wasn\u0026rsquo;t my first project in Unreal Engine, but it was the first time I experimented more with mechanics out of the norm but without going too overboard. I love the Katamari franchise, so I thought it would be a nice idea to make my own version of it to practice. I only limited myself to blueprints since it was a really small project.\nRoll movement #\rThe rolling movement itself wasn\u0026rsquo;t hard to implement as it was straightforward to apply the object\u0026rsquo;s rotation to the correct vector axis. Metasounds #\rA really distinctive feature of the Katamari franchise is its music, which draws a lot of inspiration from the Japanese pop sub-genre Shibuya-kei. I really wanted to capture that vibe in my project, so I set out to find songs that matched the style and mood to include in the game.. While I was thinking of how to implemnt an in-game music player that lets the player choose which song they want to listen to during the game, I stumbled across MetaSounds, a really complete audio system I had never heard of before. After reading some documentation, I found out that I can make my own music library and trigger switches to change the song linking them to the music player\u0026rsquo;s widget buttons to skip to the next or previous song.\nAndroid build #\rHaving experience developing mobile games in Unity, to make Android builds is fairly easy. You only have to install the necessary SDKs and JDKs through the Unity Hub installer. But I didn\u0026rsquo;t know it was a bit more complicated to do so in Unreal Engine 5.\nFirst, I had to go to Visual Studio and install the Windows 11 and 10 SDKs. Then, I had to download Android Studio and choose the SDK platforms. I also had to pick the correct SDK Tools and thanks to a post in the Unreal Engine forum, I managed to set them correctly.\nThe real trouble happened while installing the JDKs, I had to go through Oracle\u0026rsquo;s JDK version history and downnload the proper JDK according to the Unreal Engine version I was using back then, which is 5.0, but it didn\u0026rsquo;t stop there. In order for the JDK to work, I had to set a new environment variable dedicated to the newly downloaded file in my desktop. Then do the Android Setup directly on my Unreal Engine\u0026rsquo;s folder and from there setup the local SDK paths directly in the Unreal Engine editor.\nIt was tedious, but I was able to make build an .apk in Unreal Engine 5.0. Here\u0026rsquo;s a video of the game running on Android, the quality isn\u0026rsquo;t the best.\nCredits #\r3D assets: Low Poly Town by PolyArt3D Music: songs are not mine and I give all credits to capsule. Here\u0026rsquo;s a list of the songs I used: Candy Cutie (Instrumental) by capsule Happy life generator (Instrumental) by capsule Uchuu elevator (Instrumental) by capsule Idol fancy (Instrumental) by capsule Ocean blue sky orange (Instrumental) by capsule Tokyo smiling (Instrumental) by capsule Plastic girl (Instrumental) by capsule DISCLAIMER: This project was just made for fun and not commercial intends. Since it has copyrighted music, it\u0026rsquo;s not available in sites such as itch.io either\r","date":"April 2023","externalUrl":null,"permalink":"/projects/katamari-not/","section":"Projects","summary":"Katamari clone made in Unreal Engine 5, including in-game song selection.","title":"Katamari NOT!","type":"projects"},{"content":"","date":"April 2023","externalUrl":null,"permalink":"/tags/ue5/","section":"Tags","summary":"","title":"UE5","type":"tags"},{"content":"\rProject info #\rEngine: Unity\nPlatforms: Windows\nThis is a small Unity project designed to practice math and linear algebra concepts through code. You control a dice that rolls across a grid, face by face. The goal is to bring the score down to zero. To do so, you must step on numbered cells to trigger the score change, the dice\u0026rsquo;s top face value is multiplied by the cell\u0026rsquo;s number and subtracted from the total score. Each numbered cell can only be used once, so plan your moves carefully.\nFeatures #\rGrid based rolling: move the dice across a grid, but careful, you have to plan your moves. Math driven puzzles: each level challenges your logic and math skills. Retrowave aesthetic: enjoy the glowing colors and synth music. Things I learned #\rI\u0026rsquo;ve always liked linear algebra and math, so I took this as an opportunity to implement them through code. Unity offers many functions to do it directly.\nCross Product #\rThe cross product is widely used in games and 3D graphics. It takes two vectors and returns a third vector perpendicular to both, it\u0026rsquo;s often used to find surface normals, define orientations and calculate directions.\nTherefore, to rotate the dice, it\u0026rsquo;s necessary to find the rotation point, which is different from the center. The dice\u0026rsquo;s edges are used as anchor points to rotate around a pivot. To find the anchor position, the pivot is offset by half a unit along the X and Y vector directions and to determine the rotation axis, the cross product is calculated between the upward vector (Y axis) and the left vector (X axis) resulting in a perpendicular Z axis.\nprivate void RollDirection(Vector3 dir) { var anchor = transform.position + (Vector3.down + dir) * 0.5f; var axis = Vector3.Cross(Vector3.up, dir); Roll(anchor, axis).Forget(); } private async UniTask Roll(Vector3 anchor, Vector3 axis) { _isMoving = true; int steps = Mathf.CeilToInt(90f / _speed); for (int i = 0; i \u0026lt; steps; i++) { transform.RotateAround(anchor, axis, _speed); await UniTask.Delay(10); } _isMoving = false; } For the axis, the cross product is calculated between the possitive direction on the Y axis by the direction the player wants to move.\nvar axis = Vector3.Cross(Vector3.up, direction)\nLet Vector3.up = (0, 1, 0), direction = Vector3.left = (-1, 0, 0). As we can see in the following image, the calculation results in a vector (0, 0, 1).\nDot product #\rThe dot product is an important concept as well. It multiplies two vectors to produce a scalar that reflects how much the vectors point in the same direction.\nIn this project, the dot product is used to determine the orientation of vectors and compare them to identify the current top face of the dice.\nvoid CurrentFace() { float maxProd = -1; for (int i = 0; i \u0026lt; _unitVector.Length; ++i) { var vectors = _unitVector[i]; var worldVector = transform.localToWorldMatrix.MultiplyVector(vectors); float dotProduct = Vector3.Dot(worldVector, Vector3.up); if (dotProduct \u0026gt; maxProd) { maxProd = dotProduct; _faceVector = i; } } results = faces[_faceVector]; _value = Convert.ToInt32(results); _faceValue.text = _value.ToString(); } ","date":"November 2022","externalUrl":null,"permalink":"/highlights/rolling-in-the-90s/","section":"Highlights","summary":"Math puzzle game with a retrowave style, where the player has to roll a dice in order to get the score down to zero.","title":"Rollin' in the 90's","type":"highlights"},{"content":"\rProject info #\rEngine: Unity\nPlatforms: Windows\nThis is a small Unity project designed to practice math and linear algebra concepts through code. You control a dice that rolls across a grid, face by face. The goal is to bring the score down to zero. To do so, you must step on numbered cells to trigger the score change, the dice\u0026rsquo;s top face value is multiplied by the cell\u0026rsquo;s number and subtracted from the total score. Each numbered cell can only be used once, so plan your moves carefully.\nFeatures #\rGrid based rolling: move the dice across a grid, but careful, you have to plan your moves. Math driven puzzles: each level challenges your logic and math skills. Retrowave aesthetic: enjoy the glowing colors and synth music. Things I learned #\rI\u0026rsquo;ve always liked linear algebra and math, so I took this as an opportunity to implement them through code. Unity offers many functions to do it directly.\nCross Product #\rThe cross product is widely used in games and 3D graphics. It takes two vectors and returns a third vector perpendicular to both, it\u0026rsquo;s often used to find surface normals, define orientations and calculate directions.\nTherefore, to rotate the dice, it\u0026rsquo;s necessary to find the rotation point, which is different from the center. The dice\u0026rsquo;s edges are used as anchor points to rotate around a pivot. To find the anchor position, the pivot is offset by half a unit along the X and Y vector directions and to determine the rotation axis, the cross product is calculated between the upward vector (Y axis) and the left vector (X axis) resulting in a perpendicular Z axis.\nprivate void RollDirection(Vector3 dir) { var anchor = transform.position + (Vector3.down + dir) * 0.5f; var axis = Vector3.Cross(Vector3.up, dir); Roll(anchor, axis).Forget(); } private async UniTask Roll(Vector3 anchor, Vector3 axis) { _isMoving = true; int steps = Mathf.CeilToInt(90f / _speed); for (int i = 0; i \u0026lt; steps; i++) { transform.RotateAround(anchor, axis, _speed); await UniTask.Delay(10); } _isMoving = false; } For the axis, the cross product is calculated between the possitive direction on the Y axis by the direction the player wants to move.\nvar axis = Vector3.Cross(Vector3.up, direction)\nLet Vector3.up = (0, 1, 0), direction = Vector3.left = (-1, 0, 0). As we can see in the following image, the calculation results in a vector (0, 0, 1).\nDot product #\rThe dot product is an important concept as well. It multiplies two vectors to produce a scalar that reflects how much the vectors point in the same direction.\nIn this project, the dot product is used to determine the orientation of vectors and compare them to identify the current top face of the dice.\nvoid CurrentFace() { float maxProd = -1; for (int i = 0; i \u0026lt; _unitVector.Length; ++i) { var vectors = _unitVector[i]; var worldVector = transform.localToWorldMatrix.MultiplyVector(vectors); float dotProduct = Vector3.Dot(worldVector, Vector3.up); if (dotProduct \u0026gt; maxProd) { maxProd = dotProduct; _faceVector = i; } } results = faces[_faceVector]; _value = Convert.ToInt32(results); _faceValue.text = _value.ToString(); } ","date":"November 2022","externalUrl":null,"permalink":"/projects/rolling-in-the-90s/","section":"Projects","summary":"Math puzzle game with a retrowave style, where the player has to roll a dice in order to get the score down to zero.","title":"Rollin' in the 90's","type":"projects"},{"content":"I\u0026rsquo;m a game developer passionate about creating engaging and interactive experiences. I specialize in building intuitive mechanics, dynamic systems and polished player interactions. I love creating games that feel unique in mechanics and story tellings. Adding small touches that make the experience much more memorable and enjoyable for players.\nI specialize in Unity, but I also enjoy diving inot other engines like Unreal Engine to experiment, learn and discover new things and ways to bring my ideas to life.\nSeveral games have inspired me to become a game crafter, titles like Okami, ICO and Rez showed me how games can move players emotionally and leave their mark on them, not just entertain them.\nMy objective is to create experiences that make others feel the same way I did when I first played those games. I want to evoke the same connection, wonder and excitement, and create worlds that players will remember long after they\u0026rsquo;ve finished them.\n","date":"June 2022","externalUrl":null,"permalink":"/about/","section":"Cristina Vera","summary":"","title":"About","type":"page"},{"content":"\rProject info #\rRole\r\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;Description\rGame Designer\rCo-design\r\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;Co-designed core mechanics and game phases.\rTeam members: 2\nGame Type: Board game\nGenre: Roll and write\nAbout #\rBlueprint Studio is a roll and write game for 1 to 4 players where players take the ole of architects who have to draw the plans for a house and complete rooms with the right objects. Whoever designs the house with the highest value, wins.\nI co-designed this board game with the talented Alejandro Luna as a college projecet. It was well received by our professors, José Macías and Ruben Hernandez, who offered us the opportunity to take it further and collaborate with Tabletop Workshops to launch a Kickstarter campaign.\nKickstarter campaign #\r","date":"May 2022","externalUrl":null,"permalink":"/projects/blueprint-studio/","section":"Projects","summary":"In this game, you step into the shoes of an architect, tasked with designing the ultimate dream house.","title":"Blueprint Studio","type":"projects"},{"content":"","date":"May 2022","externalUrl":null,"permalink":"/tags/board-game/","section":"Tags","summary":"","title":"Board Game","type":"tags"},{"content":"","date":"May 2022","externalUrl":null,"permalink":"/tags/kickstarter/","section":"Tags","summary":"","title":"Kickstarter","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]